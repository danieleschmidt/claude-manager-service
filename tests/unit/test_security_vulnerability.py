"""
Security tests for command injection vulnerabilities
"""
import pytest
from unittest.mock import Mock, patch, MagicMock
import sys
import shlex

sys.path.append('/root/repo/src')


class TestCommandInjectionSecurity:
    """Test cases for command injection vulnerabilities"""

    def setup_method(self):
        """Setup method run before each test"""
        self.mock_api = Mock()
        self.mock_api.token = 'test_token'
        
        # Mock issue with potentially malicious title
        self.mock_issue = Mock()
        self.mock_issue.number = 123
        self.mock_issue.body = "Test body"
        self.mock_issue.html_url = "https://github.com/test/repo/issues/123"
        self.mock_issue.labels = []

    @patch('orchestrator.get_validated_config')
    @patch('orchestrator.SecureTempDir')
    @patch('orchestrator.get_secure_subprocess')
    def test_command_injection_vulnerability_basic(self, mock_subprocess, mock_temp_dir, mock_config):
        """Test that malicious issue titles with shell metacharacters are properly handled"""
        from orchestrator import trigger_claude_flow_task
        
        # Malicious issue title with command injection attempt
        self.mock_issue.title = 'test"; rm -rf /tmp; echo "pwned'
        
        # Mock the secure subprocess
        mock_secure_subprocess = Mock()
        mock_result = Mock()
        mock_result.returncode = 0
        mock_result.stdout = "success"
        mock_secure_subprocess.run_git_clone.return_value = mock_result
        mock_secure_subprocess.run_with_sanitized_logging.return_value = mock_result
        mock_subprocess.return_value = mock_secure_subprocess
        
        # Mock temp directory
        from pathlib import Path
        mock_temp_dir.return_value.__enter__.return_value = Path("/tmp/test")
        
        # Execute the function
        trigger_claude_flow_task(self.mock_api, "test/repo", self.mock_issue)
        
        # Check that the command was constructed safely
        called_args = mock_secure_subprocess.run_with_sanitized_logging.call_args[0][0]
        
        # The command should be structured as a list where each element is a separate argument
        # This prevents shell interpretation of metacharacters
        assert called_args[0] == "npx"
        assert called_args[1] == "claude-flow@alpha"  
        assert called_args[2] == "hive-mind"
        assert called_args[3] == "spawn"
        assert called_args[4] == 'test"; rm -rf /tmp; echo "pwned'  # Title is passed as single argument
        assert called_args[5] == "--claude"
        
        # Since we're passing as a list, the malicious content is treated as a single argument
        # and cannot be executed as separate commands - this is the security fix

    @patch('orchestrator.get_validated_config')
    @patch('orchestrator.SecureTempDir')
    @patch('orchestrator.get_secure_subprocess')
    def test_command_injection_vulnerability_backticks(self, mock_subprocess, mock_temp_dir, mock_config):
        """Test that backtick command substitution is prevented"""
        from orchestrator import trigger_claude_flow_task
        
        # Malicious issue title with backtick command substitution
        self.mock_issue.title = 'test`whoami`test'
        
        # Mock the secure subprocess
        mock_secure_subprocess = Mock()
        mock_result = Mock()
        mock_result.returncode = 0
        mock_result.stdout = "success"
        mock_secure_subprocess.run_git_clone.return_value = mock_result
        mock_secure_subprocess.run_with_sanitized_logging.return_value = mock_result
        mock_subprocess.return_value = mock_secure_subprocess
        
        # Mock temp directory
        from pathlib import Path
        mock_temp_dir.return_value.__enter__.return_value = Path("/tmp/test")
        
        # Execute the function
        trigger_claude_flow_task(self.mock_api, "test/repo", self.mock_issue)
        
        # Check that the command was constructed safely
        called_args = mock_secure_subprocess.run_with_sanitized_logging.call_args[0][0]
        
        # The command should be structured as a list where backticks are treated as literal characters
        # This prevents command substitution since each element is a separate argument  
        assert called_args[0] == "npx"
        assert called_args[1] == "claude-flow@alpha"
        assert called_args[2] == "hive-mind" 
        assert called_args[3] == "spawn"
        assert called_args[4] == 'test`whoami`test'  # Backticks are literal, not executed
        assert called_args[5] == "--claude"
        
        # Since we're passing as a list, backticks are treated as literal characters
        # and command substitution cannot occur - this is the security fix

    @patch('orchestrator.get_validated_config')
    @patch('orchestrator.SecureTempDir')
    @patch('orchestrator.get_secure_subprocess')
    def test_safe_issue_title_handling(self, mock_subprocess, mock_temp_dir, mock_config):
        """Test that normal issue titles work correctly after security fix"""
        from orchestrator import trigger_claude_flow_task
        
        # Normal issue title
        self.mock_issue.title = 'Fix login bug in authentication module'
        
        # Mock the secure subprocess
        mock_secure_subprocess = Mock()
        mock_result = Mock()
        mock_result.returncode = 0
        mock_result.stdout = "success"
        mock_secure_subprocess.run_git_clone.return_value = mock_result
        mock_secure_subprocess.run_with_sanitized_logging.return_value = mock_result
        mock_subprocess.return_value = mock_secure_subprocess
        
        # Mock temp directory
        from pathlib import Path
        mock_temp_dir.return_value.__enter__.return_value = Path("/tmp/test")
        
        # Execute the function
        trigger_claude_flow_task(self.mock_api, "test/repo", self.mock_issue)
        
        # Check that the command was constructed correctly
        called_args = mock_secure_subprocess.run_with_sanitized_logging.call_args[0][0]
        
        # Verify the command structure is correct
        assert called_args[0] == "npx"
        assert called_args[1] == "claude-flow@alpha"
        assert called_args[2] == "hive-mind"
        assert called_args[3] == "spawn"
        assert called_args[5] == "--claude"
        
        # The task description should contain the issue title safely
        task_description = called_args[4]
        assert 'Fix login bug in authentication module' in task_description

    def test_shlex_quote_behavior(self):
        """Test shlex.quote behavior for different inputs"""
        # Test that shlex.quote properly handles malicious inputs
        malicious_inputs = [
            'test"; rm -rf /tmp; echo "pwned',
            'test`whoami`test',
            "test$(whoami)test",
            "test && rm -rf /tmp",
            "test | cat /etc/passwd",
            "test; cat /etc/passwd",
            'test\'; DROP TABLE users; --',
        ]
        
        for malicious_input in malicious_inputs:
            quoted = shlex.quote(malicious_input)
            # After quoting, the string should be safe to use in shell commands
            # The quote should contain the entire malicious input as a single token
            assert quoted.startswith("'") or quoted.startswith('"') or '\\' in quoted
            
            # Test that when the quoted string is parsed back, it's treated as a single argument
            parsed = shlex.split(quoted)
            assert len(parsed) == 1
            assert parsed[0] == malicious_input